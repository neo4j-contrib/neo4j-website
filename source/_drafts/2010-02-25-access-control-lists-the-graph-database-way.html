---
layout: post
title: "Access control lists the graph database way"
date: 2010-02-25
comments: false
categories:
 - ruby
 - example
 - jruby
 - graphdb
 - acl
---

<div class='post'>
<br /><p>In many contexts you need to handle user permissions to access, create or change some kind of resources. A common example is a file system, and that's what we are going to dive into in this blog post. We're going to use <a href="http://github.com/andreasronge/neo4j">Ruby bindings</a> for the <a href="http://neo4j.org/">Neo4j graph database</a> to create a small - but working - example application.</p><h2>Preparation</h2><p>To set up the environment for this example on Ubuntu, I used the following commands:</p><pre class="brush: plain">sudo apt-get install jruby<br />sudo jruby -S gem install neo4j</pre><p>To import the libraries, the following code was used:</p><pre class="brush: ruby">require 'rubygems'<br />require 'neo4j'<br />require 'neo4j/extensions/find_path'</pre><h2>Heading for the node space</h2><p>So user permissions, what are they all about? Obviously it's about users, and usually user groups as well. We'll abstract this away a bit and use the term <em>principals</em>, which can be single users or groups.</p><p>The other side of user permissions are the resources which are to be protected. In our case we'll have a file system, so there will be folders and files. Here we'll use the term <em>content</em>.</p><p>Let's start out building a graph to support the application from what we have gathered so far! When working with a graph it's beneficial to think in a graphy manner, so that's where we'll begin. Graphs are presumably about connecting things, so our first step is to create some relationships. Neo4j comes with a built-in <em>reference node</em>, which is easily accessible at all times. We use this to create our own "subreference nodes", one for principals and one for content. This is how our graph looks so far:</p><p><img src="acl-subref.png" /></p><p>To create (and get) the subreference nodes, we use this function:</p><pre class="brush: ruby">def get_or_create_sub_ref( name )<br />  result = Neo4j.ref_node.rels.outgoing( name ).nodes.first<br />  if ( result.nil? )<br />    result = Neo4j::Node.new :name => name.to_s.capitalize.gsub("_", " ")<br />    Neo4j.ref_node.rels.outgoing( name ) << result<br />  end<br />  return result<br />end</pre><p>This function is then called whenever we need to use a subreference node. The important parts here are:</p><ul><li><code>ref_node</code>: the built-in reference node</li><li><code>rels</code>: relationships connected to a node</li><li><code>outgoing</code>: the direction of the relationship (the relationships are always directed, but you can choose to ignore the direction in traversals)</li><li><code>( name )</code>: the type of relationships to follow (the type can be ignored in traversals as well, but in our case we want to use it)</li><li><code>nodes</code>: the nodes in the other end of the relationships</li><li><code>first</code>: the first node found - there sould only be one subreference node of each type</li></ul><p>If the subreference node isn't found, it will be created and connected to the reference node. As you can see, we're adding a property with the key <code>name</code> to the nodes as well, which is there solely for the purpose of visualization (the images in this post are created using <a href="http://neoclipse.org/">Neoclipse</a>).</p><h2>Basic structure</h2><p>For the principals part, we are going to connect the top-level ones to the corresponding subreference node using a <code>PRINCIPAL</code> type of relationship. Other than that, there's just users and groups, so let's use a <code>IS_MEMBER_OF_GROUP</code> relationship type to encode that. This is how this looks in the graph:</p><p><img src="acl-principals.png" /></p><p>And here's the code to create it:</p><pre class="brush: ruby">def new_principal( name, member_of_groups = [] )<br />  principal = Neo4j::Node.new<br />  principal[ :name ] = name<br />  if member_of_groups.empty?<br />    get_or_create_sub_ref( :PRINCIPALS ).rels.outgoing( :PRINCIPAL ) << principal<br />  else<br />    for group in member_of_groups<br />      principal.rels.outgoing( :IS_MEMBER_OF_GROUP ) << group<br />    end<br />  end<br />  return principal<br />end</pre><p>If a new principal isn't member of any groups, it's added as a top-level principal, connected to the principals subrefererence node. In other case, it's simply added to the groups.</p><p>With Neo4j all operations on the graph have to be encapsulated in a transaction, so this is how we'll call the above function:</p><pre class="brush: ruby">Neo4j::Transaction.run do<br />  all_principals = new_principal( "All principals" )<br />  root = new_principal( "root", [ all_principals ] )<br />  regular_users = new_principal( "Regular users", [ all_principals ] )<br />  user1 = new_principal( "user1", [ regular_users ] )<br />  user2 = new_principal( "user2", [ regular_users ] )<br />end</pre><p>For the content part, things are very similar to the principals part. The main difference is that in this case, an item can have only a single parent item. Here's the graphical view on that:</p><p><img src="acl-content.png" /></p><p>And this is the code to create the structure:</p><pre class="brush: ruby">def new_content( name, parent = nil )<br />  content = Neo4j::Node.new<br />  content[ :name ] = name<br />  if ( parent.nil? )<br />    get_or_create_sub_ref( :CONTENT_ROOTS ).rels.outgoing( :CONTENT_ROOT ) << content<br />  else<br />    parent.rels.outgoing( :HAS_CHILD_CONTENT ) << content<br />  end<br />  return content<br />end</pre><p>Similar to how the principals were created, this is the code to create the content data:</p><pre class="brush: ruby">Neo4j::Transaction.run do<br />  root_folder = new_content( "Root folder" )<br />  temp_folder = new_content( "Temp", root_folder )<br />  home_folder = new_content( "Home", root_folder )<br />  user1_home_folder = new_content( "user1 home", home_folder )<br />  user2_home_folder = new_content( "user2 home", home_folder )<br />  a_file = new_content( "MyFile.pdf", user1_home_folder )<br />end</pre><h2>At the core</h2><p>Now that we have the basic structure in place, what's left regarding our data is a small but crucial part: the permissions information! We're using a simple scheme: adding security relationships with optional boolean flags for read and write permission. Not much to say here, this is what we want the full graph to look like:</p><p><img src="acl-all.png" /></p><p>A small function will help us add the security information:</p><pre class="brush: ruby">def apply_security( content, principal, map_with_flags )<br />  security_relationship = Neo4j::Relationship.new( :SECURITY, principal, content )<br />  map_with_flags.each_pair {|key, value| security_relationship[ key ] = value}<br />end</pre><p>It's time to add the security data:</p><pre class="brush: ruby">Neo4j::Transaction.run do<br />  apply_security( root_folder, root, { "w" => true } )<br />  apply_security( root_folder, all_principals, { "r" => true } )<br />  apply_security( temp_folder, all_principals, { "w" => true } )<br />  apply_security( user1_home_folder, regular_users, { "r" => false, "w" => false } )<br />  apply_security( user1_home_folder, user1, { "r" => true, "w" => true } )<br />  apply_security( user2_home_folder, user2, { "r" => true, "w" => true } )<br />end</pre><p>To check the permission for some action by an actual principal for some content, there's some work to do. This is the algorithm we use to retrieve a permission flag:</p><ol><li>Move from the content node and upwards through the file system structure and investigate each level for permission information.</li><li>On each level, see if there are any principals related to or identical with the principal concerned.</li><li>Make sure to use the permission information from the principal closest to the principal concerned.</li><li>If permission information was found, return it; otherwise, continue traversing to the next level in the file system.</li></ol><p>In the code for this, we'll use a function named <code>depth_of_principal()</code> to calculate the distance between the principal we have traversed to and the principal concerned. More on that later, here's the code to check the permissions:</p><pre class="brush: ruby">def has_access( content, principal, flag )<br />  for current_content in content.incoming( :HAS_CHILD_CONTENT ).depth( :all )<br />    lowest_score = nil<br />    lowest_modifier = nil<br />    for rel in current_content.rels.incoming( :SECURITY )<br />      rel_principal = rel.start_node<br />      if !rel[ flag ].nil?<br />        score = depth_of_principal( rel_principal, principal )<br />        if !score.nil?<br />          modifier = rel[ flag ]<br />          if lowest_score.nil? || score < lowest_score ||<br />            ( score == lowest_score && modifier )<br />            lowest_score = score<br />            lowest_modifier = modifier<br />          end<br />        end<br />      end<br />    end<br />    if !lowest_modifier.nil?<br />      return lowest_modifier<br />    end<br />  end<br />  return false<br />end</pre><p>Here's our function to check the distance between principals (and to see if they're on the same path at all).</p><pre class="brush: ruby">def depth_of_principal( principal, reference_principal )<br />  result = reference_principal.outgoing( :IS_MEMBER_OF_GROUP ).depth( :all ).path_to( principal )<br />  return result.nil? ? nil : result.size<br />end</pre><p>Finally, we want to see that everything works, so here's a utility function to print permission information:</p><pre class="brush: ruby"><br />def print_has_access( content, principal, flag )<br />  print principal[ :name ] + " +" + flag.upcase + " access to " + content[ :name ] + "? " +<br />    has_access( content, principal, flag ).to_s + "\n"<br />end</pre><p>And here's how to use the function:</p><pre class="brush: ruby">Neo4j::Transaction.run do<br />  print_has_access( home_folder, root, "w" )<br />  print_has_access( home_folder, user1, "w" )<br />  print_has_access( a_file, root, "r" )<br />  print_has_access( a_file, user2, "r" )<br />  print_has_access( a_file, user1, "w" )<br />end</pre><h2>Next steps</h2><p>The full source code is found <a href="https://svn.neo4j.org/examples/acl/">here</a></p><p>Here's a few useful resources to help you on your way:</p><ul><li><a href="http://wiki.neo4j.org/">Neo4j Wiki</a></li><li><a href="http://github.com/andreasronge/neo4j">Neo4j.rb</a> at github</li><li><a href="http://neo4j.org/community/list/">mailing lists</a> - good places to get help</li><li><a href="http://blog.neo4j.org/2010/02/top-10-ways-to-get-to-know-neo4j.html">The top 10 ways to get to know Neo4j</a></li></ul><p>Thanks for reading - any feedback is welcome!</p></div>
